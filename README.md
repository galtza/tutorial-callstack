:information_source: Medium level

# Tutorial: call-stack

According to [Wikipedia](https://en.wikipedia.org/wiki/Call\_stack), 

"*A call stack is a data structure that stores information about the **active subroutines** in a computer program*". 

Before we continue, notice that we use a stack as the underlying storage and...

> remember that a [Stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) is a data structure with two main operations: **Push** and **Pop**. The order in which an element is added to or removed from a stack is described as *last in*, *first out*: **LIFO**.

So, the stack is used to pass information between subroutines. There are some pieces of information that are **explicit** like in the parameters of functions and others that are **implicit** like those generated by the subroutine calling mechanism.

The latest is what we are going to be talking about in this tutorial.

#### A Basic Example

Let's reason about this with a particular example. Imagine that we have two functions **Foo** and **Bar**. The function **Foo** calls the function **Bar** with the value *42* as a parameter and after that it prints out the message *Done!*:

```c++
1 void Bar(int n);
2 void Foo () {
3    Bar(42);
4    printf("Done!\n");
5 }
```

We can guess that there is an explicit call to **Push(42)** into the stack so that **Bar** can access the value. However, implicitly something more happens. 

Imagine for a moment that we eventually managed to pass the control to the function **Bar**. Imagine too that **Bar** is done executing. What happens now? How do we restore the execution of **Foo**? How do we print our the message?

The answer is the [Calling Convention](https://en.wikipedia.org/wiki/Calling_convention) which describes how this extra information is added to the stack and how it is interpreted. By inspecting the assembly code that is generated from the example above, we can spot the two instructions that transfer the execution and return back: ***call*** and ***ret***.

> Bare in mind that we do not intent to be super thorough by talking about assembly but it is **absolutely** essential that we do so.

The instruction [***call***](https://c9x.me/x86/html/file_module_x86_id_26.html)  

*Saves procedure linking information on the stack and branches to the procedure*

The instruction [***ret***](https://c9x.me/x86/html/file_module_x86_id_280.html) 

*Transfers program control to a return address located on the top of the stack ... the return address is popped*

So, in our example, Before **Bar** is executed two things happen:

* The compiler pushes 42 to the stack
* The ***call*** assembly instruction pushes the address of the next instruction (*printf*) into the stack
* The ***call*** assembly instruction transfer the execution to the function **Bar**

Now, when **Bar** finishes executing its code:

* The ***ret*** assembly instruction will pop the return address from the stack 
* The ***ret*** assembly instruction will transfer the execution to the aforementioned address

Now that we have a basic knowledge about how subroutines communicate with each other, we can focus on the higher level concept of the call-stack. 

> Be aware that we will **NOT** describe how to retrieve the a call stack from the stack memory where there is a series of interleaved parameters and return addresses. It is not a complicated procedure but It is not the intention of this article.

#### A more complex example

Now that we can focus on the call stack, let's consider a more complex example:

```c++
 1 #include <cstdio>
 2 
 3 void print_result(int _val) {
 4     printf ("Result = %d", _val);
 5 }
 6 
 7 int factorial(unsigned int n) {
 8     auto factorial = 1;
 9     for(auto i = 1u; i <= n; ++i) {
10         factorial *= i;
11     }    
12     print_result(factorial);    
13     return factorial;
14 }
15 
16 void foo(int _num) {
17     factorial(_num);
18 }
19 
20 int main () {
21     foo (10);
22     return 0;
23 }
```

In this particular case the sequence of calls is in this order:

* *main* (called by the C++ runtime among others before it), 
* *foo*, 
* *factorial*
* *print_result*. 

Let's go further and see how this program translates into assembly. For that we will be using the amazing [Godbolt](https://godbolt.org/z/M9c3rc6nY) compiler explorer for this. Check out the link and explore it yourself.

The main function source code and corresponding binary assembly code generated will be like this:

![](pics/main_function.png)

On the left there is the source code with the line numbers at the beginning of each line, and on the right there are the corresponding assembly instructions. The numbers on the right side of each line are the memory addresses of the assembly instructions. 

Notice that there is **no 1 to 1 correspondence** between a line in the source code and the corresponding assembly instructions. This is fundamental in order to understand how code memory addresses will be translated into useful information. More about that later.

Similarly *foo* looks like this:

![](pics/foo_function.png)

which is pretty much the same. Now, a more complex one; *factorial*:

![](pics/factorial_function.png)

This one is a bit more complex and shows us interesting things. Notice how some source lines of code correspond to different non-sequential groups of instructions like the *for* loop in line 9 that corresponds to address blocks *[401172, 40117F]* and *[40118F, 401198]*.

Finally the *print_result* function:

![](pics/print_result_function.png)

Notice that it calls another function we did not write ourselves: *printf*. 

So, what if we wanted to find out how the call stack would look like if we stopped the execution when we are about to run the *printf* function? In that particular case, the subroutines that are active are *main*, *foo*, *factorial* and *print_result*. 

Step by step!

Firstly at line 21 we need to look into the corresponding assembly instruction at **4011e4**. As we described before, the ***call*** assembly instruction will push into the stack the value **4011e9** which is the address of the next instruction commonly called the *return address*. 

Similarly once we are inside *foo* at source line 17 (assembly address **4011be**), another *call* will be invoked, hence, the address **4011c3** will be pushed into the stack. We have two so far: **4011e9** and on top of it **4011c3**. If we keep tracking the execution until we get to *print_result* at assembly memory address **40113b** the stack should contain this:


![](pics/stack.png)

So, what happens now?

![](pics/stack_usage.png)













There are a few things to consider that are relevant for our case:

1. **Very** rarely (line 10 -> instruction at 4011eb) there is a 1 to 1 correspondence between one line of C++ source code and one assembly instruction.
2. Not only there is no 1 to 1 correspondence, sometimes it is not even sequential (line 11 corresponds to blocks  4011f2-4011FF and 40120F-401218).

so, what do we retrieve

```c++
main -> foo -> bar -> factorial -> print_result
```



This very simple program is translated to assembly code as we can see in the boxes around 

If we captured the call stack **in line 2**, we would get a series of memory addresses. Starting by the current execution point (address corresponding to line 2) Each of them represent it would be a sequence of memory return addresses. This means that after the execution of *baz* it will return the control to  corresponding with this particular source code at lines 2 (the current instruction pointer), 7 (right after the call) and 11 (right after the call as well) in that order. the 2, 7 and 11 numbers are what we want to see but internally they are represented by memory addresses.

:warning:A  warning

