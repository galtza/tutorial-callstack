:information_source: Medium level

# Tutorial: call-stack

According to [Wikipedia](https://en.wikipedia.org/wiki/Call\_stack), 

"*A call stack is a data structure that stores information about the **active subroutines** in a computer program*". 

Before we continue, notice that we use a stack as the underlying storage and...

> remember that a [Stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) is a data structure with two main operations: **Push** and **Pop**. The order in which an element is added to or removed from a stack is described as *last in*, *first out*: **LIFO**.

So, the stack is used to pass information between subroutines. There are some pieces of information that are **explicit** like in the parameters of functions and others that are **implicit** like those generated by the subroutine calling mechanism.

The latest is what we are going to be talking about in this tutorial.

#### A Basic Example

Let's reason about this with a particular example. Imagine that we have two functions **Foo** and **Bar**. The function **Foo** calls the function **Bar** with the value *42* as a parameter and after that it prints out the message *Done!*:

```c++
1 void Bar(int n);
2 void Foo () {
3    Bar(42);
4    printf("Done!\n");
5 }
```

We can guess that there is an explicit call to **Push(42)** into the stack so that **Bar** can access the value. However, implicitly something more happens. 

Imagine for a moment that we eventually managed to pass the control to the function **Bar**. Imagine too that **Bar** is done executing. What happens now? How do we restore the execution of **Foo**? How do we print our the message?

The answer is the [Calling Convention](https://en.wikipedia.org/wiki/Calling_convention) which describes how this extra information is added to the stack and how it is interpreted. By inspecting the assembly code that is generated from the example above, we can spot the two instructions that transfer the execution and return back: ***call*** and ***ret***.

> Bare in mind that we do not intent to be super thorough by talking about assembly but it is **absolutely** essential that we do so.

The instruction [***call***](https://c9x.me/x86/html/file_module_x86_id_26.html)  

*Saves procedure linking information on the stack and branches to the procedure*

The instruction [***ret***](https://c9x.me/x86/html/file_module_x86_id_280.html) 

*Transfers program control to a return address located on the top of the stack ... the return address is popped*

So, in our example, Before **Bar** is executed two things happen:

* The compiler pushes 42 to the stack
* The ***call*** assembly instruction pushes the address of the next instruction (*printf*) into the stack
* The ***call*** assembly instruction transfer the execution to the function **Bar**

Now, when **Bar** finishes executing its code:

* The ***ret*** assembly instruction will pop the return address from the stack 
* The ***ret*** assembly instruction will transfer the execution to the aforementioned address

Now that we have a basic knowledge about how subroutines communicate with each other, we can focus on the higher level concept of the call-stack. 

> Be aware that we will **NOT** describe how to retrieve the a call stack from the stack memory where there is a series of interleaved parameters and return addresses. It is not a complicated procedure but It is not the intention of this article.

#### A more complex example

Now that we can focus on the call stack, let's consider a more complex example:

```c++
 1 #include <cstdio>
 2 
 3 void print_result(int _val) {
 4     printf ("Result = %d", _val);
 5 }
 6 
 7 int factorial(unsigned int n) {
 8     auto factorial = 1;
 9     for(auto i = 1u; i <= n; ++i) {
10         factorial *= i;
11     }    
12     print_result(factorial);    
13     return factorial;
14 }
15 
16 void foo(int _num) {
17     factorial(_num);
18 }
19 
20 int main () {
21     foo (10);
22     return 0;
23 }
```

In this particular case the sequence of calls is in this order:

* *main* (called by the C++ runtime among others before it), 
* *foo*, 
* *factorial*
* *print_result*. 

Let's go further and see how this program translates into assembly. For that we will be using the amazing [Godbolt](https://godbolt.org/z/M9c3rc6nY) compiler explorer for this. Check out the link and explore it yourself.

The main function source code and corresponding binary assembly code generated will be like this:

![](pics/main_function.png)

On the left there is the source code with the line numbers at the beginning of each line, and on the right there are the corresponding assembly instructions. The numbers on the right side of each line are the memory addresses of the assembly instructions. 

Notice that there is **no 1 to 1 correspondence** between a line in the source code and the corresponding assembly instructions. This is fundamental in order to understand how code memory addresses will be translated into useful information. More about that later.

Similarly *foo* looks like this:

![](pics/foo_function.png)

which is pretty much the same. Now, a more complex one; *factorial*:

![](pics/factorial_function.png)

This one is a bit more complex and shows us interesting things. Notice how some source lines of code correspond to different non-sequential groups of instructions like the *for* loop in line 9 that corresponds to address blocks *[401172, 40117F]* and *[40118F, 401198]*.

Finally the *print_result* function:

![](pics/print_result_function.png)

Notice that it calls another function we did not write ourselves: *printf*. 

So, what if we wanted to find out how the call stack would look like if we stopped the execution when we are about to run the *printf* function? In that particular case, the subroutines that are active are *main*, *foo*, *factorial* and *print_result*. 

Step by step!

Firstly at line 21 we need to look into the corresponding assembly instruction at **4011E4**. As we described before, the ***call*** assembly instruction will push into the stack the value **4011e9** which is the address of the next instruction commonly called the *return address*. 

Similarly once we are inside *foo* at source line 17 (assembly address **4011BE**), another *call* will be invoked, hence, the address **4011C3** will be pushed into the stack. We have two so far: **4011E9** and on top of it **4011C3**. 

If we keep simulating until we just executed *print_result* (source line 5, assembly address **40114F**) the call stack inside the stack should be like this:


![](pics/stack.png)

So, what happens now? Take a look at the picture and we will reason about it!

![](pics/stack_usage.png)

| source line / hex mem address | description of what happens as we step over                  |
| ----------------------------- | ------------------------------------------------------------ |
| 5 / 40114f                    | three instructions execute from which ***ret*** is the relevant one. ***ret*** will pop **4011A5** from the stack and transfer the execution to that memory address |
| 13 / 4011A5                   | It will execute 3 assembly instructions until it gets to ***ret*** where it will pop **4011C3** from the stack and, again, transfer the execution to the address |
| 18 / 4011C3                   | Again, it will execute assembly until it gets to the ***ret*** at 4011C8 and it will pop the last address in our example which is **4011E9** and transfer the execution |
| 22 / 4011E9                   | It will get the return address that the corresponding ***call*** instruction invoked *main* in the first place (which is not included in this example) |



#### Conclusions

* The call stack is a sequence of return addresses
* The call stack is stored interleaved with other elements in the stack
* The instruction pair ***call***/***ret*** is the mechanism that controls the flow between subroutines
* There is no 1:1 correspondence between source code and assembly code.



:warning:warning

